-- =======================
-- M2GO Supabase All-in-One Setup
-- =======================

-- =======================
-- 1) Schema
-- =======================
create table if not exists products (
  id integer generated by default as identity primary key,
  name_zh text not null,
  name_en text not null,
  category text not null,
  storage_type text not null,
  supplier text,
  case_pack double precision,
  min_order_qty double precision,
  is_active boolean default true,
  sort_order integer
);

-- 防止同名商品跨分类重复（也覆盖“同分类重复”）
create unique index if not exists products_name_zh_unique on products (lower(name_zh));

-- 限制分类取值
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'products_category_check'
  ) then
    alter table products
      add constraint products_category_check
      check (category in ('protein', 'veg', 'frozen'));
  end if;
end $$;

create table if not exists variants (
  id integer generated by default as identity primary key,
  product_id integer references products(id),
  form text not null,
  container text not null,
  conversion_to_base double precision,
  display_name_zh text not null,
  sort_order integer
);

create table if not exists inventory_balances (
  variant_id integer primary key references variants(id),
  on_hand double precision default 0
);

create table if not exists daily_counts (
  id integer generated by default as identity primary key,
  date text not null,
  variant_id integer references variants(id),
  counted_qty double precision not null,
  prev_on_hand double precision,
  adjustment double precision,
  created_at timestamp default now()
);

create table if not exists orders (
  id integer generated by default as identity primary key,
  order_date text not null,
  order_type text not null,
  status text default 'DRAFT',
  created_at timestamp default now()
);

create table if not exists order_lines (
  id integer generated by default as identity primary key,
  order_id integer references orders(id),
  product_id integer references products(id),
  suggested_qty double precision default 0,
  final_qty double precision default 0,
  unit text not null,
  reason_json jsonb,
  notes text
);

create table if not exists settings (
  key text primary key,
  value text not null
);

create table if not exists audit_logs (
  id bigserial primary key,
  table_name text not null,
  action text not null,
  row_id text,
  old_data jsonb,
  new_data jsonb,
  user_id uuid,
  created_at timestamp default now()
);

-- =======================
-- 2) RLS & Permissions
-- =======================
do $$
declare r record;
begin
  for r in
    select tablename from pg_tables where schemaname = 'public'
  loop
    execute format('alter table public.%I enable row level security;', r.tablename);
    execute format('drop policy if exists allow_auth_all on public.%I;', r.tablename);
    execute format(
      'create policy allow_auth_all on public.%I
       for all
       using (auth.role() = ''authenticated'')
       with check (auth.role() = ''authenticated'');',
      r.tablename
    );
  end loop;
end $$;

grant usage on schema public to authenticated;
grant all on all tables in schema public to authenticated;
alter default privileges in schema public grant all on tables to authenticated;
grant usage, select on all sequences in schema public to authenticated;
alter default privileges in schema public grant usage, select on sequences to authenticated;

-- Restrict audit_logs to read/insert only (no update/delete)
drop policy if exists allow_auth_all on public.audit_logs;
drop policy if exists audit_logs_select on public.audit_logs;
drop policy if exists audit_logs_insert on public.audit_logs;
create policy audit_logs_select on public.audit_logs
  for select using (auth.role() = 'authenticated');
create policy audit_logs_insert on public.audit_logs
  for insert with check (auth.role() = 'authenticated');

-- =======================
-- 3) Functions
-- =======================
create or replace function public.apply_daily_count(
  p_date text,
  p_variant_id integer,
  p_counted_qty numeric
) returns void
language plpgsql
security definer
set search_path = public
as $$
declare prev_on_hand numeric;
begin
  select on_hand into prev_on_hand
  from inventory_balances
  where variant_id = p_variant_id;

  if prev_on_hand is null then
    prev_on_hand := 0;
  end if;

  insert into daily_counts (date, variant_id, counted_qty, prev_on_hand, adjustment, created_at)
  values (p_date, p_variant_id, p_counted_qty, prev_on_hand, p_counted_qty - prev_on_hand, now());

  insert into inventory_balances (variant_id, on_hand)
  values (p_variant_id, p_counted_qty)
  on conflict (variant_id)
  do update set on_hand = excluded.on_hand;
end $$;

grant execute on function public.apply_daily_count(text, integer, numeric) to authenticated;

-- =======================
-- 4) Audit Triggers
-- =======================
create or replace function public.log_audit()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare v_row_id text;
begin
  if (tg_op = 'DELETE') then
    v_row_id := coalesce(old.id::text, old.key::text, old.variant_id::text);
    insert into audit_logs (table_name, action, row_id, old_data, new_data, user_id)
    values (tg_table_name, 'DELETE', v_row_id, to_jsonb(old), null, auth.uid());
    return old;
  elsif (tg_op = 'UPDATE') then
    v_row_id := coalesce(new.id::text, old.id::text, new.key::text, old.key::text, new.variant_id::text, old.variant_id::text);
    insert into audit_logs (table_name, action, row_id, old_data, new_data, user_id)
    values (tg_table_name, 'UPDATE', v_row_id, to_jsonb(old), to_jsonb(new), auth.uid());
    return new;
  else
    v_row_id := coalesce(new.id::text, new.key::text, new.variant_id::text);
    insert into audit_logs (table_name, action, row_id, old_data, new_data, user_id)
    values (tg_table_name, 'INSERT', v_row_id, null, to_jsonb(new), auth.uid());
    return new;
  end if;
end $$;

drop trigger if exists audit_products on public.products;
create trigger audit_products after insert or update or delete on public.products
  for each row execute function public.log_audit();

drop trigger if exists audit_variants on public.variants;
create trigger audit_variants after insert or update or delete on public.variants
  for each row execute function public.log_audit();

drop trigger if exists audit_inventory_balances on public.inventory_balances;
create trigger audit_inventory_balances after insert or update or delete on public.inventory_balances
  for each row execute function public.log_audit();

drop trigger if exists audit_daily_counts on public.daily_counts;
create trigger audit_daily_counts after insert or update or delete on public.daily_counts
  for each row execute function public.log_audit();

drop trigger if exists audit_orders on public.orders;
create trigger audit_orders after insert or update or delete on public.orders
  for each row execute function public.log_audit();

drop trigger if exists audit_order_lines on public.order_lines;
create trigger audit_order_lines after insert or update or delete on public.order_lines
  for each row execute function public.log_audit();

drop trigger if exists audit_settings on public.settings;
create trigger audit_settings after insert or update or delete on public.settings
  for each row execute function public.log_audit();
